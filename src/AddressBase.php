<?php

namespace Dxw\CIDR;

abstract class AddressBase
{
	/** @var string */
	private $address;

	/** @var int */
	protected static $size;

	public static function Make(string $address): \Dxw\Result\Result
	{
		// I hate to suppress warnings, but there's no other way to disable
		// warnings generated by inet_pton, and we are handling it
		$_address = @inet_pton($address);
		if ($_address === false) {
			return \Dxw\Result\Result::err('inet_pton error: unrecognised address');
		}

		return \Dxw\Result\Result::ok(new static($_address));
	}

	final private function __construct(string $address)
	{
		$this->address = $address;
	}

	public function __toString(): string
	{
		$value = inet_ntop($this->address);

		// $value should never be false since the address gets parsed by
		// inet_pton() before being passed to the constructor
		if ($value === false) {
			throw new \ErrorException("inet_ntop error: return value was false");
		}
		return $value;
	}

	public static function FromBinary(\phpseclib\Math\BigInteger $binary): \Dxw\Result\Result
	{
		if ($binary->compare(new \phpseclib\Math\BigInteger(0)) < 0) {
			return \Dxw\Result\Result::err('address cannot be negative');
		}

		$numBytes = intdiv(static::$size, 4);
		$numNibbles = intdiv(static::$size, 8);

		if (strlen($binary->toHex()) > $numBytes) {
			return \Dxw\Result\Result::err(sprintf('address size cannot exceed %s bytes', static::$size));
		}

		$bytes = $binary->toBytes();
		$bytes = str_pad($bytes, $numNibbles, "\x00", STR_PAD_LEFT);

		return \Dxw\Result\Result::ok(new static($bytes));
	}

	public function getBinary(): \phpseclib\Math\BigInteger
	{
		return new \phpseclib\Math\BigInteger($this->address, 256);
	}
}
